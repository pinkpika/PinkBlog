<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pink Blog</title>
  <icon>https://www.gravatar.com/avatar/5c6581fa74d8841029b0c88328e88401</icon>
  <subtitle>Simplicity is the soul of efficiency.</subtitle>
  <link href="http://pinkpika.github.io/pinkblog/atom.xml" rel="self"/>
  
  <link href="http://pinkpika.github.io/pinkblog/"/>
  <updated>2022-02-11T16:42:39.830Z</updated>
  <id>http://pinkpika.github.io/pinkblog/</id>
  
  <author>
    <name>pinkpika</name>
    <email>tim801217@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>XCTest 和 Unit Testing Bundle</title>
    <link href="http://pinkpika.github.io/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/"/>
    <id>http://pinkpika.github.io/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/</id>
    <published>2022-02-06T08:15:10.000Z</published>
    <updated>2022-02-11T16:42:39.830Z</updated>
    
    <content type="html"><![CDATA[<p>開始寫測試前必須先瞭解該平台用來寫測試的套件或框架，<br>例如 C# 的 MSTest、Java 的 JUnit、JavaScript 的 JsUnit，<br>當然在 iOS 平台上也有專屬的測試框架 XCTest。</p><h1 id="XCTest"><a href="#XCTest" class="headerlink" title="XCTest"></a>XCTest</h1><p>XCTest 是 Apple 官方出的測試框架，可以用來建立 Unit Testing、Performance Testing、UI Testing。</p><ul><li><a href="https://developer.apple.com/documentation/xctest">xctest 官方文件</a></li></ul><h1 id="Unit-Testing-Bundle"><a href="#Unit-Testing-Bundle" class="headerlink" title="Unit Testing Bundle"></a>Unit Testing Bundle</h1><p>Unit Testing Bundle 則是 Xcode 內建用來做單元測試的 Target。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ol><li><p>新增 Target &gt; iOS Unit Testing Bundle (在建立專案時其實也可以直接勾選 Include Tests)</p><img src="/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/1.png" class="" width="600"></li><li><p>命名 Target 名稱 &gt; 完成安裝</p><img src="/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/2.png" class="" width="600"></li><li><p>通常需要測試的物件都在專案裡，所以 <code>TestAppTests.swift</code> 需要在最上面加上 <code>@testable import TestApp</code></p></li><li><p>也可以自行新增測試檔案進行分類，建議是一個類別對一個測試檔案，不要把所有類別的測試都寫在同一個檔案</p></li></ol><img src="/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/5.png" class="" width="800"><h2 id="撰寫測試"><a href="#撰寫測試" class="headerlink" title="撰寫測試"></a>撰寫測試</h2><h3 id="Setup-和-Teardown"><a href="#Setup-和-Teardown" class="headerlink" title="Setup 和 Teardown"></a>Setup 和 Teardown</h3><ul><li>SetUp：在測試執行前做一些初始化的設定。</li><li>TearDown：測試結束後，在這裡清除資料或設定，確保不會留下任何可能影響後續測試的東西。</li></ul><p>目前官方有提供很多種進階用法 <a href="https://developer.apple.com/documentation/xctest/xctestcase/set_up_and_tear_down_state_in_your_tests">Set Up and Tear Down State in Your Tests</a><br>例如初始化方式就有分同步或非同步，<br>或是提供 <code>addTeardownBlock</code> 來定義特定測試的 TearDown。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 非同步執行初始化設定，並且可以 throws error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUpWithError</span>()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// 同步執行初始化設定，並且可以 throws error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步執行初始化設定</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="XCTAssert"><a href="#XCTAssert" class="headerlink" title="XCTAssert"></a>XCTAssert</h3><p>用來驗證結果是否如預期，有很多種判斷方式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> data <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> object: <span class="type">Date</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 判斷是否為True</span></span><br><span class="line"><span class="type">XCTAssert</span>(result)</span><br><span class="line"><span class="comment">// 判斷是否為false</span></span><br><span class="line"><span class="type">XCTAssertFalse</span>(result)</span><br><span class="line"><span class="comment">// 判斷是否相同</span></span><br><span class="line"><span class="type">XCTAssertEqual</span>(data, <span class="number">100</span>)</span><br><span class="line"><span class="comment">// 判斷是否不相同</span></span><br><span class="line"><span class="type">XCTAssertNotEqual</span>(data, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 判斷是否為空</span></span><br><span class="line"><span class="type">XCTAssertNil</span>(object)</span><br><span class="line"><span class="comment">// 判斷是否不為空</span></span><br><span class="line"><span class="type">XCTAssertNotNil</span>(object)</span><br><span class="line"><span class="comment">// 無條件失敗</span></span><br><span class="line"><span class="type">XCTFail</span>()</span><br></pre></td></tr></table></figure><img src="/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/3.png" class="" width="600"><h3 id="執行方式"><a href="#執行方式" class="headerlink" title="執行方式"></a>執行方式</h3><p>xcode 的介面上就有三種按法可以跑測試，當然也可以用終端機跑測試。<br>第一種比較特別，是要設定過 Scheme，並且長按編譯按鈕，然後改成執行測試。<br>第二或三種比較單純，直接執行單一檔案或是單一測試。</p><img src="/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/4.png" class="" width="800"><h3 id="單元測試命名"><a href="#單元測試命名" class="headerlink" title="單元測試命名"></a>單元測試命名</h3><ul><li>必須以前綴 test 開頭、不帶參數、不返回值，是否用底線由團隊而定</li><li>最好名稱能夠敘述測試的內容，或是包含預期的結果</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test_NumberTool_IsPositive()</span><br><span class="line">testNumberToolIsPositive()</span><br><span class="line">testDataManagerGetDataFromServerStatusCode200()</span><br><span class="line">testDataManagerGetDataFromServerStatusCode400()</span><br></pre></td></tr></table></figure><hr><h1 id="如何把程式寫成可測試"><a href="#如何把程式寫成可測試" class="headerlink" title="如何把程式寫成可測試"></a>如何把程式寫成可測試</h1><ol><li>乾淨的架構 ( MVC、MVVM、VIPER、Clean 等等架構，架構的細膩程度會直接影響能測試的程度 )</li><li>職責單一的物件</li><li>抽離檔案系統 ( UserDefault or File )、資料庫 ( DataBase )、遠端資料 ( Api )<ul><li>抽離的方式最常見的就是使用 Protocol 抽離實作，並且使用依賴注入 ( DI ) 換成假資料</li><li>或是使用一些實作好 Mock 的套件，例如 <a href="https://cocoapods.org/pods/MockUserDefaults">MockUserDefaults</a></li></ul></li></ol><hr><h1 id="常見的測試案例"><a href="#常見的測試案例" class="headerlink" title="常見的測試案例"></a>常見的測試案例</h1><h2 id="對-Model-測試"><a href="#對-Model-測試" class="headerlink" title="對 Model 測試"></a>對 Model 測試</h2><p>可測試 Model 的建構式或是方法。</p><figure class="highlight swift"><figcaption><span>Cake.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cake</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> price: <span class="type">Double</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getPrice</span>(<span class="params">discount</span>: <span class="type">Double</span>)</span> -&gt; <span class="type">Double</span>?&#123;</span><br><span class="line">        <span class="keyword">guard</span> discount <span class="operator">&lt;=</span> <span class="number">1.0</span> <span class="operator">&amp;&amp;</span> discount <span class="operator">&gt;=</span> <span class="number">0.0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> price <span class="operator">*</span> (<span class="number">1</span> <span class="operator">-</span> discount)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><figcaption><span>CakeTests.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testCakeGetPrice</span>()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cake <span class="operator">=</span> <span class="type">Cake</span>(name: <span class="string">&quot;Strawberry Cake&quot;</span>, price: <span class="number">120</span>)</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> cake.getPrice(discount: <span class="number">0.2</span>)</span><br><span class="line">    <span class="type">XCTAssertEqual</span>(result, <span class="number">96</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="對-API-測試"><a href="#對-API-測試" class="headerlink" title="對 API 測試"></a>對 API 測試</h2><p>針對 Server 呼叫 API 進行測試，確認回應物件是否如預期，<br>因為會依賴真實伺服器，所以不是單元測試而是整合測試。</p><p>官方針對非同步測試也有寫文章 - <a href="https://developer.apple.com/documentation/xctest/asynchronous_tests_and_expectations/testing_asynchronous_operations_with_expectations">Testing Asynchronous Operations with Expectations</a><br>需要建立 XCTestExpectation 並使用 wait，才能確保非同步下測試會正常。</p><figure class="highlight swift"><figcaption><span>DataManagerTests.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDataManagerGetData</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 宣告expectation</span></span><br><span class="line">    <span class="keyword">let</span> expect <span class="operator">=</span> expectation(description: <span class="string">&quot;DataManager getData&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> dataManager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">    dataManager.getData() &#123; </span><br><span class="line">        result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> result &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">            <span class="type">XCTAssert</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="type">XCTAssert</span>(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成結果</span></span><br><span class="line">        expect.fulfill()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待非同步結果，timeout 時間為 30 秒</span></span><br><span class="line">    wait(for: [expect], timeout: <span class="number">30.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="對真實環境的抽離並測試"><a href="#對真實環境的抽離並測試" class="headerlink" title="對真實環境的抽離並測試"></a>對真實環境的抽離並測試</h2><p>當遇到檔案系統、資料庫、遠端資料，可用 Protocol 抽離實作並依賴注入(DI)<br>利用假資料來進行完整的商業邏輯的測試。</p><p>下面有四步驟：</p><ol><li>將呼叫遠端資料的邏輯都封裝在一個物件 <code>CakeAPIProvider</code>，好處是方便抽離</li><li>建立一個 protocol <code>CakeProvider</code>，把要抽離的方法都定義出來</li><li>真正在管理資料的 <code>CakeManager</code> 只要使用該 protocol 呼叫各種商業邏輯</li></ol><figure class="highlight swift"><figcaption><span>CakeProvider.swift CakeAPIProvider.swift CakeManager.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CakeProvider</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getData</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ((<span class="type">Result</span>&lt;<span class="type">Cake</span>,<span class="type">Error</span>&gt;)-&gt;<span class="type">Void</span>))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CakeAPIProvider</span>: <span class="title">CakeProvider</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getData</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ((<span class="type">Result</span>&lt;<span class="type">Cake</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>))</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;...&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="type">AF</span>.request(url).response&#123;</span><br><span class="line">            response <span class="keyword">in</span></span><br><span class="line">            <span class="comment">//completion(...)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CakeManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> provider: <span class="type">CakeProvider</span> <span class="operator">=</span> <span class="type">CakeAPIProvider</span>()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getCakePrice</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ((<span class="type">Result</span>&lt;<span class="type">Double</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>))</span>&#123;</span><br><span class="line">        provider.getData &#123;</span><br><span class="line">            result <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> result&#123;</span><br><span class="line">            <span class="keyword">case</span> .success(<span class="keyword">let</span> cake):</span><br><span class="line">                completion(.success(cake.price))</span><br><span class="line">            <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                completion(.failure(error))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//func ...</span></span><br><span class="line">    <span class="comment">//func ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>到時候要進行測試或抽換實作時，只要換 <code>CakeManager</code> 的 provider 即可！</li></ol><figure class="highlight swift"><figcaption><span>CakeManagerTests.swift</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CakeMockProvider</span>: <span class="title">CakeProvider</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getData</span>(<span class="params">completion</span>: <span class="keyword">@escaping</span> ((<span class="type">Result</span>&lt;<span class="type">Cake</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>))</span> &#123;</span><br><span class="line">        completion(.success(<span class="type">Cake</span>(name: <span class="string">&quot;MockCake&quot;</span>, price: <span class="number">100</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CakeManagerTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testCakeManager</span>()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cakeManager <span class="operator">=</span> <span class="type">CakeManager</span>()</span><br><span class="line">        cakeManager.provider <span class="operator">=</span> <span class="type">CakeMockProvider</span>() <span class="comment">// 這裡進行抽換</span></span><br><span class="line">        cakeManager.getCakePrice &#123;</span><br><span class="line">            result <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> result&#123;</span><br><span class="line">            <span class="keyword">case</span>.success(<span class="keyword">let</span> price):</span><br><span class="line">                <span class="type">XCTAssertEqual</span>(price, <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                <span class="type">XCTFail</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="測試覆蓋率-Code-Coverage"><a href="#測試覆蓋率-Code-Coverage" class="headerlink" title="測試覆蓋率 (Code Coverage)"></a>測試覆蓋率 (Code Coverage)</h1><p>測試覆蓋率可以用來看在跑測試的過程中，有多少比例的程式有執行到。</p><h2 id="建立方式"><a href="#建立方式" class="headerlink" title="建立方式"></a>建立方式</h2><p>編輯 Scheme &gt; Test &gt; 勾選 Code Coverage，<br>可以選擇特定 target，盡量選擇自己專案就好，不然會包含一些三方依賴。 </p><img src="/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/6.png" class="" width="800"><h2 id="查看結果"><a href="#查看結果" class="headerlink" title="查看結果"></a>查看結果</h2><p>可以從 xcode 的活動紀錄裡看到 Coverage</p><img src="/pinkblog/2022/02/06/XCTest-%E5%92%8C-Unit-Testing-Bundle/7.png" class="" width="800"><p>追求 100％ 的測試覆蓋率其實不太容易，<br>更何況前端很多是 UI 相關的程式碼，也不是那麼容易寫單元測試，<br>至少確認重要邏輯或是關鍵路徑已經被測試就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;開始寫測試前必須先瞭解該平台用來寫測試的套件或框架，&lt;br&gt;例如 C# 的 MSTest、Java 的 JUnit、JavaScript 的 JsUnit，&lt;br&gt;當然在 iOS 平台上也有專屬的測試框架 XCTest。&lt;/p&gt;
&lt;h1 id=&quot;XCTest&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="iOS Development" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/"/>
    
    <category term="Testing" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/Testing/"/>
    
    
  </entry>
  
  <entry>
    <title>Unit Testing 的入門介紹</title>
    <link href="http://pinkpika.github.io/pinkblog/2022/02/06/Unit-Testing-%E7%9A%84%E5%85%A5%E9%96%80%E4%BB%8B%E7%B4%B9/"/>
    <id>http://pinkpika.github.io/pinkblog/2022/02/06/Unit-Testing-%E7%9A%84%E5%85%A5%E9%96%80%E4%BB%8B%E7%B4%B9/</id>
    <published>2022-02-06T05:56:37.000Z</published>
    <updated>2022-02-06T18:24:48.732Z</updated>
    
    <content type="html"><![CDATA[<p>常常聽到說寫測試可以確保程式碼品質、幫助我們不會修壞程式碼，<br>那具體來說測試到底是什麼樣的東西呢？</p><h1 id="單元測試-Unit-Testing"><a href="#單元測試-Unit-Testing" class="headerlink" title="單元測試 (Unit Testing)"></a>單元測試 (Unit Testing)</h1><p>單元測試是一組驗證功能的程式碼，這段程式會呼叫被測試的工作單元，並且針對結果進行驗證，<br>為了可以在開發過程中或是發布之前可以找到邏輯錯誤的功能，通常都會加在 CI/CD 的流程中。</p><p>一組單元測試通常有三個步驟：</p><ol><li>Arrange：準備 =&gt; 初始化並設定好要測驗的物件</li><li>Act：操作 =&gt; 執行要驗證的方法</li><li>Assert：驗證 =&gt; 對結果進行驗證是不是符合預期</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testNumberToolIsPositive</span>()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Arrange：準備</span></span><br><span class="line">    <span class="keyword">let</span> numberTool <span class="operator">=</span> <span class="type">NumberTool</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Act：操作</span></span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> numberTool.isPositive(input: <span class="number">999</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Assert：驗證</span></span><br><span class="line">    <span class="type">XCTAssert</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="單元測試的關鍵特質"><a href="#單元測試的關鍵特質" class="headerlink" title="單元測試的關鍵特質"></a>單元測試的關鍵特質</h1><ol><li>自動化且可被重複執行的</li><li>容易實作的</li><li>容易執行的 (隨便按個鈕就可以)</li><li>非臨時性的 (這個測試到第二天第三天仍有意義，並可以執行)</li><li>執行速度很快的</li><li>執行結果一致的</li><li>完全獨立的 (不依賴其他因素或測試)</li><li>測試目標清楚的 (發生錯誤可以明確知道哪裡有問題)</li></ol><div class="note warning flat"><p>假設你的測試有不符合上面單元測試的特質，很有可能你的是屬於”整合測試”</p></div><h1 id="整合測試-Integration-Testing"><a href="#整合測試-Integration-Testing" class="headerlink" title="整合測試 (Integration Testing)"></a>整合測試 (Integration Testing)</h1><p>當你的測試依賴某種環境或是帶有不定因素(例如系統時間、網路狀態)，<br>或是用到了真實的檔案系統或是資料庫等等，這些測試都將屬於整合測試。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testDataManagerGetDataFromServer</span>()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> dataManager <span class="operator">=</span> <span class="type">DataManager</span>()</span><br><span class="line">    dataManager.getDataFromServer &#123; <span class="comment">// ---&gt; 假設此方法呼叫了Api</span></span><br><span class="line">        result <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> result&#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> data):</span><br><span class="line">            <span class="type">XCTAssert</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="type">XCTAssert</span>(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合測試依然有必要，但有個問題就是一次測試太多東西，<br>無法確定到底是誰壞了，到底是前端 API 物件寫壞還是 Server 目前是壞掉的呢？</p><hr><div class="note warning flat"><p>寫好單元測試就好了嗎？</p></div><img src="/pinkblog/2022/02/06/Unit-Testing-%E7%9A%84%E5%85%A5%E9%96%80%E4%BB%8B%E7%B4%B9/unitTests.gif" class="" width="300" title="兩個完美的單元測試，不代表運作會正常..."><hr><h1 id="測試金字塔-Testing-Pyramid"><a href="#測試金字塔-Testing-Pyramid" class="headerlink" title="測試金字塔 (Testing Pyramid)"></a>測試金字塔 (Testing Pyramid)</h1><p>前端往往包含大量 UI 的互動和多樣的資料來源，<br>如果只依靠單元測試，可能沒辦法完全測試出可能的問題，所以衍伸出不同層級的測試方式，也就是測試金字塔。<br>網路上有各種不同的版本，依照不同產品可衍生不同分層，但是想表達的概念都大同小異！</p><img src="/pinkblog/2022/02/06/Unit-Testing-%E7%9A%84%E5%85%A5%E9%96%80%E4%BB%8B%E7%B4%B9/testing-pyramid.png" class="" width="500"><p>這裡簡單說明最常見的三層：</p><table><thead><tr><th></th><th>定義</th><th>特點</th></tr></thead><tbody><tr><td>UI測試(UI Testing)</td><td>從使用者角度的測試，實際操作App</td><td>速度慢、撰寫成本高、維護成本高</td></tr><tr><td>整合測試(Integration Testing)</td><td>測試包含實際的伺服器、DB</td><td>介於中間</td></tr><tr><td>單元測試(Unit Testing)</td><td>單純測試邏輯，並隔離所有外部因素</td><td>速度快、撰寫成本低、維護成本低</td></tr></tbody></table><p>撰寫測試的順序是由下至上，像是蓋房子一樣，<br>通常單元測試是涵蓋範圍最大的，需要針對大部分的 <strong>基底物件方法和商業邏輯</strong> 進行測試，<br>而整合測試、UI測試應該會越來越少才對，對 <strong>關鍵路徑(Critical Path)</strong> 進行測試即可。</p><h1 id="推薦書單"><a href="#推薦書單" class="headerlink" title="推薦書單"></a>推薦書單</h1><p><a href="https://www.tenlong.com.tw/products/9789864342471?list_name=srh">單元測試的藝術(The Art of Unit Testing)</a></p><p>最重要的三個章節：</p><ul><li>第1章：單元測試定義</li><li>第8章：好的單元測試</li><li>第11章：如何讓程式變可測試</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常常聽到說寫測試可以確保程式碼品質、幫助我們不會修壞程式碼，&lt;br&gt;那具體來說測試到底是什麼樣的東西呢？&lt;/p&gt;
&lt;h1 id=&quot;單元測試-Unit-Testing&quot;&gt;&lt;a href=&quot;#單元測試-Unit-Testing&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="iOS Development" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/"/>
    
    <category term="Testing" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/Testing/"/>
    
    
  </entry>
  
  <entry>
    <title>SwiftLint 靜態檢查器</title>
    <link href="http://pinkpika.github.io/pinkblog/2022/02/01/SwiftLint-%E9%9D%9C%E6%85%8B%E6%AA%A2%E6%9F%A5%E5%99%A8/"/>
    <id>http://pinkpika.github.io/pinkblog/2022/02/01/SwiftLint-%E9%9D%9C%E6%85%8B%E6%AA%A2%E6%9F%A5%E5%99%A8/</id>
    <published>2022-02-01T05:40:55.000Z</published>
    <updated>2022-02-01T07:08:53.123Z</updated>
    
    <content type="html"><![CDATA[<p>本篇會介紹 Coding Style 與 iOS 平台上最活躍的靜態檢查器 SwiftLint，<br>可以幫助你的程式碼保持一致的風格，並且讓團隊有相同的規範可以遵循。</p><h1 id="CodingStyle"><a href="#CodingStyle" class="headerlink" title="CodingStyle"></a>CodingStyle</h1><p>CodingStyle 就是指寫作程式碼的風格，其中包含很多面向，<br>例如說是變數命名方式、是否有空格、是否要換行、註解格式、修飾詞的順序等等，<br>有時程式碼的功能是相同的，但是會因為風格的不同導致看起來差很多，嚴重一點甚至會有閱讀上的困難，<br>因此往往成熟的團隊會需要訂定一套規則來規範它。</p><h1 id="CodingStyle-規則"><a href="#CodingStyle-規則" class="headerlink" title="CodingStyle 規則"></a>CodingStyle 規則</h1><p>CodingStyle 規則就像一份穿搭規則，可以讓團隊裡的程式碼保持下面三個特點。</p><ol><li>可讀性</li><li>易維護</li><li>一致性</li></ol><p>自己定義一套穿搭規則其實蠻不容易的，因此可以參考下面兩個網站。</p><ol><li><a href="https://www.swift.org/documentation/api-design-guidelines/">swift.org - API Design Guidelines</a><ul><li>swift 官方的 API 設計方式，比較偏概念性</li></ul></li><li><a href="https://github.com/raywenderlich/swift-style-guide">raywenderlich - Swift Style</a><ul><li>raywenderlich 出的一套 CodingStyle，目前算是開源社群裡最多人遵循的的一套規則</li><li>定義的規則也相當明確，會跟你說什麼是對的、什麼是錯的</li></ul></li></ol><h1 id="CodingStyle-靜態檢查器"><a href="#CodingStyle-靜態檢查器" class="headerlink" title="CodingStyle 靜態檢查器"></a>CodingStyle 靜態檢查器</h1><p>有了穿搭規則還需要一位服裝審核員幫我們檢驗，檢查程式碼是否有依照規則穿搭，<br>最大的好處是可以自動化地檢查寫作風格是否正確，甚至有些可以幫你自動修正。</p><h2 id="SwiftLint"><a href="#SwiftLint" class="headerlink" title="SwiftLint"></a>SwiftLint</h2><p><a href="https://github.com/realm/SwiftLint">SwiftLint</a> 則是 <a href="https://github.com/realm">realm</a> 公司出的一款 CodingStyle 靜態檢查器，<br>選用此工具原因是目前熱門獨大且唯一持續更新，<br>而且 SwiftLint 的預設規則就遵循大部分 raywenderlich 的 Swift Style。</p><h3 id="安裝方式"><a href="#安裝方式" class="headerlink" title="安裝方式"></a>安裝方式</h3><ol><li><p>在終端機輸入下方指令，專案初始化pod (請事先電腦安裝過 CocoaPods)</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure></li><li><p>設定 PodFile，開啟專案內的 PodFile 檔案加入下面程式碼</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;SwiftLint&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在終端機輸入下方指令，安裝三方</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure></li><li><p>設定 Build Phases，開啟專案內設定Build Phases &gt; 按 “＋” &gt; RunScript &gt; 輸入下方腳本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint&quot; lint</span><br></pre></td></tr></table></figure></li></ol><h3 id="執行方法"><a href="#執行方法" class="headerlink" title="執行方法"></a>執行方法</h3><p>直接按下編譯即可！</p><img src="/pinkblog/2022/02/01/SwiftLint-%E9%9D%9C%E6%85%8B%E6%AA%A2%E6%9F%A5%E5%99%A8/1.png" class="" width="800"><h3 id="禁用規則"><a href="#禁用規則" class="headerlink" title="禁用規則"></a>禁用規則</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swiftlint:disable colon</span></span><br><span class="line"><span class="keyword">let</span> noWarning :<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> <span class="comment">// 我被跳過了</span></span><br><span class="line"><span class="comment">// swiftlint:enable colon</span></span><br><span class="line"><span class="keyword">let</span> hasWarning :<span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> <span class="comment">// 我被禁止了</span></span><br></pre></td></tr></table></figure><h3 id="規則清單"><a href="#規則清單" class="headerlink" title="規則清單"></a>規則清單</h3><p>下面連結的每一條都是一條規則，有些是預設有、有些是預設沒有，<br>並且每一條都有詳細的範例說明怎樣是正確的、怎樣是錯誤的。</p><p><a href="https://realm.github.io/SwiftLint/rule-directory.html">Rule Directory</a></p><h3 id="客製化規則"><a href="#客製化規則" class="headerlink" title="客製化規則"></a>客製化規則</h3><p>當然有時候會需要調整成適合團隊的規範，請先依照下面步驟調整 Config，<br>最後細部調整 Config 檔案內的規則即可。</p><ol><li><p>調整 Build Phases</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;$&#123;PODS_ROOT&#125;/SwiftLint/swiftlint&quot; lint --config &quot;$&#123;SRCROOT&#125;/swiftlint.yml&quot;</span><br></pre></td></tr></table></figure></li><li><p>放入規則設定檔，放在專案的根目錄，叫做”swiftlint.yml”</p></li><li><p>一樣直接按下編譯即可！</p></li></ol><img src="/pinkblog/2022/02/01/SwiftLint-%E9%9D%9C%E6%85%8B%E6%AA%A2%E6%9F%A5%E5%99%A8/2.png" class="" width="800"><h3 id="客製化規則範例"><a href="#客製化規則範例" class="headerlink" title="客製化規則範例"></a>客製化規則範例</h3><p>Swiftlint 的客製化規則是非常彈性的，<br>可以開啟或關閉某些規則，<br>甚至可以用正規表達式定義全新的規則，<br>發生不符合規則要觸發”warning”或是”error”也可以自由決定，<br>也可以跳過固定的路徑的檢查，例如 Pods 裡的三方檔案，避免浪費檢查效能，<br>最後連報錯的方式也提供很多種，例如 xcode, json … 等等支援各式各樣的報告。</p><p>這裡有一個完整範例可以參考：<a href="https://github.com/pinkpika/SwiftLintDemo/blob/main/swiftlint.yml">swiftlint.yml</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不啟用的規則</span></span><br><span class="line"><span class="attr">disabled_rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用的規則</span></span><br><span class="line"><span class="attr">opt_in_rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客製化的規則</span></span><br><span class="line"><span class="attr">custom_rules:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行linting包含的路徑</span></span><br><span class="line"><span class="attr">included:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行linting忽略的路徑(優先度大於included)</span></span><br><span class="line"><span class="attr">excluded:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 報錯類型</span></span><br><span class="line"><span class="attr">reporter:</span> <span class="string">&quot;xcode&quot;</span></span><br></pre></td></tr></table></figure><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ul><li><a href="https://github.com/sleekbyte/tailor">tailor</a>：另一套靜態檢查器<ul><li>但有個嚴重問題，目前只支援到Swift3.0，無人更新…</li></ul></li><li><a href="https://github.com/nicklockwood/SwiftFormat">SwiftFormat</a>：強制格式化的工具<ul><li>尚未深入研究，但能設定的條件不夠多。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇會介紹 Coding Style 與 iOS 平台上最活躍的靜態檢查器 SwiftLint，&lt;br&gt;可以幫助你的程式碼保持一致的風格，並且讓團隊有相同的規範可以遵循。&lt;/p&gt;
&lt;h1 id=&quot;CodingStyle&quot;&gt;&lt;a href=&quot;#CodingStyle&quot; cla</summary>
      
    
    
    
    <category term="iOS Development" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/"/>
    
    <category term="CodingStyle" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/CodingStyle/"/>
    
    
  </entry>
  
  <entry>
    <title>DispatchQueue 的簡單應用</title>
    <link href="http://pinkpika.github.io/pinkblog/2022/01/26/DispatchQueue-%E7%9A%84%E7%B0%A1%E5%96%AE%E6%87%89%E7%94%A8/"/>
    <id>http://pinkpika.github.io/pinkblog/2022/01/26/DispatchQueue-%E7%9A%84%E7%B0%A1%E5%96%AE%E6%87%89%E7%94%A8/</id>
    <published>2022-01-26T06:23:27.000Z</published>
    <updated>2022-02-01T07:13:05.932Z</updated>
    
    <content type="html"><![CDATA[<p>本篇內容以非常初階的方式介紹 DispatchQueue，<br>同時會說明 iOS 體系裡最流行的多緒處理的技術 GCD 和一些應用情境和範例，<br>後來也有用在公司培訓初次接觸 iOS 工程師的一段課程裡。</p><div class="note warning flat"><p>不過本篇的主題不是最新 Swift 5.5 的 async/await，將會著重在 GCD 的 DispatchQueue</p></div><h1 id="提及-DispatchQueue-前，先需要知道多執行緒的應用程式如何運作的？"><a href="#提及-DispatchQueue-前，先需要知道多執行緒的應用程式如何運作的？" class="headerlink" title="提及 DispatchQueue 前，先需要知道多執行緒的應用程式如何運作的？"></a>提及 DispatchQueue 前，先需要知道多執行緒的應用程式如何運作的？</h1><img src="/pinkblog/2022/01/26/DispatchQueue-%E7%9A%84%E7%B0%A1%E5%96%AE%E6%87%89%E7%94%A8/1.png" class="" width="400"><ul><li>Program: <ul><li>應用程式本身</li></ul></li><li>Process: <ul><li>開啟應用程式後的實體</li><li>每個 Process 都是獨立的，無法自由讀取其他 Process 的資源</li><li>像是裝有 Thread 的容器</li></ul></li><li>Thread: <ul><li>每個 Process 會有管理多個 Thread</li><li>同一個 Process 底下的  Thread 就可以存取相同資源 (例如記憶體變數等等)</li><li>多執行緒處理需要非常細微的操作，容易發生互搶資源，死結 DeadLock 的問題</li></ul></li><li>Core: <ul><li>就是硬體上的核心，通常是多核心處理</li><li>一個 Core 通常同一時間只能處理一個 Thread (還是有些例外像是 Hyper-Threading)</li></ul></li></ul><img src="/pinkblog/2022/01/26/DispatchQueue-%E7%9A%84%E7%B0%A1%E5%96%AE%E6%87%89%E7%94%A8/2.png" class="" width="800"><div class="note info flat"><p>多執行緒程式碼可以同時間處理多項任務，然而處理多項任務就是需要操作 Thread</p></div><h1 id="iOS-的多緒開發方式"><a href="#iOS-的多緒開發方式" class="headerlink" title="iOS 的多緒開發方式"></a>iOS 的多緒開發方式</h1><ol><li><p>第一種：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html">Threading Programming Guide</a><br>自行建立 NSThread 並且需要自行管理 Autorelease Pool<br>需要定義 Atomic 變數或是自行管理 NSLock 來處理同步問題 </p></li><li><p>第二種：<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html">Concurrency Programming Guide</a><br>名為 Grand Central Dispatch ( GCD )<br>消除建立與管理 Thread 所需程式碼，僅需定義任務，讓系統自行管理排程<br>可以高效穩定地避免同步和 DeadLock 問題</p></li><li><p>第三種：<a href="https://developer.apple.com/documentation/swift/swift_standard_library/concurrency/updating_an_app_to_use_swift_concurrency">Swift Concurrency</a><br>最新的 Swift 5.5 提供了更直觀、更安全的寫法<br>包含 async/await、Actor 等等好用的語法</p></li></ol><h1 id="Grand-Central-Dispatch-GCD"><a href="#Grand-Central-Dispatch-GCD" class="headerlink" title="Grand Central Dispatch ( GCD )"></a>Grand Central Dispatch ( GCD )</h1><p>目前提供了三種方法處理多執行緒</p><ol><li>第一種：Dispatch Queues<ul><li>利用 DispatchQueue，可以輕鬆達到 asynchronously 異步和 concurrently 並發的方式，處理你的工作</li><li>依照先出原則管理</li></ul></li><li>第二種：Dispatch Sources<ul><li>可以處理 Dispatch 的底層系統事件的通知</li></ul></li><li>第三種：Operation Queues<ul><li>預設並行方式，不依照先進先出原則，根據優先順序決定</li></ul></li></ol><h1 id="DispatchQueue-的建立與發動"><a href="#DispatchQueue-的建立與發動" class="headerlink" title="DispatchQueue 的建立與發動"></a>DispatchQueue 的建立與發動</h1><h3 id="建立方式有兩種"><a href="#建立方式有兩種" class="headerlink" title="建立方式有兩種"></a>建立方式有兩種</h3><img src="/pinkblog/2022/01/26/DispatchQueue-%E7%9A%84%E7%B0%A1%E5%96%AE%E6%87%89%E7%94%A8/3.png" class="" width="400"><ol><li>Serial：串行的方式執行工作，一次只能執行一項任務</li><li>Concurrent：並發的方式執行工作，可以同時執行多項任務</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定名稱可用於取得相同 Queue 或是避免衝突</span></span><br><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;serialQueue&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> concurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;concurrentQueue&quot;</span>, attributes: .concurrent)</span><br></pre></td></tr></table></figure><p>也可以執行呼叫出系統預設的 DispatchQueue</p><ol><li>DispatchQueue.main<ul><li>屬於 Serial 方式</li><li>全域可以操作的主要 Queue</li><li>UI相關的操作必須要在這裡操作</li></ul></li><li>DispatchQueue.global<ul><li>屬於 Concurrent 方式</li><li>適合在背景處理大量計算</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.main <span class="comment">//&lt;——- 為 serial</span></span><br><span class="line"><span class="keyword">let</span> globalQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global() <span class="comment">//&lt;——- 為 concurrent</span></span><br></pre></td></tr></table></figure><h3 id="發動方式有兩種"><a href="#發動方式有兩種" class="headerlink" title="發動方式有兩種"></a>發動方式有兩種</h3><ol><li>Synchronously 同步發動：發動工作後，必須執行完成工作，才能往下執行<ul><li><code>queue.sync &#123; 定義你要做的工作 &#125;</code></li></ul></li><li>Asynchronously 異步發動：發動工作後，直接執行後續動作<ul><li><code>queue.async &#123; 定義你要做的工作 &#125;</code></li></ul></li></ol><h1 id="DispatchQueue-組合運用範例"><a href="#DispatchQueue-組合運用範例" class="headerlink" title="DispatchQueue 組合運用範例"></a>DispatchQueue 組合運用範例</h1><div class="note success flat"><p>關鍵判斷方式:<br>    - 決定 Closure 裡面可不可以執行看 Serial vs Concurrent<br>    - 決定後續是否直接執行看 Sync vs Async</p></div><img src="/pinkblog/2022/01/26/DispatchQueue-%E7%9A%84%E7%B0%A1%E5%96%AE%E6%87%89%E7%94%A8/4.png" class="" width="800"><div class="tabs" id="dispatchqueue"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dispatchqueue-1">Serial+Sync</button></li><li class="tab"><button type="button" data-href="#dispatchqueue-2">Serial+Async</button></li><li class="tab"><button type="button" data-href="#dispatchqueue-3">Concurrent+Sync</button></li><li class="tab"><button type="button" data-href="#dispatchqueue-4">Concurrent+Async</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dispatchqueue-1"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;serialQueue&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">serialQueue.sync &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;i: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.sync &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;j: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure><p>由於執行 sync 所以 Closure1 內要先執行完成，才可以往下走<br>start &gt; Closure1 &gt; Closure2 &gt; end</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">i: 1</span><br><span class="line">i: 2</span><br><span class="line">i: 3</span><br><span class="line">i: 4</span><br><span class="line">i: 5</span><br><span class="line">j: 1</span><br><span class="line">j: 2</span><br><span class="line">j: 3</span><br><span class="line">j: 4</span><br><span class="line">j: 5</span><br><span class="line">end</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dispatchqueue-2"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;serialQueue&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;i: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;j: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure><p>由於執行 async 所以可以連續執行到下一個 async 和最後一個 print end，<br>但因為是 serialQueue，所以導致先執行完第一個 Closure1 才能執行 Closure2</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">i: 1</span><br><span class="line">i: 2</span><br><span class="line">i: 3</span><br><span class="line">i: 4</span><br><span class="line">i: 5</span><br><span class="line">j: 1</span><br><span class="line">j: 2</span><br><span class="line">j: 3</span><br><span class="line">j: 4</span><br><span class="line">j: 5</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dispatchqueue-3"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;concurrentQueue&quot;</span>, attributes: .concurrent)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;i: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;j: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure><p>由於執行 sync 所以 Closure1 內要先執行完成，才可以往下走<br>所以就算是 concurrentQueue 也一樣</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">i: 1</span><br><span class="line">i: 2</span><br><span class="line">i: 3</span><br><span class="line">i: 4</span><br><span class="line">i: 5</span><br><span class="line">j: 1</span><br><span class="line">j: 2</span><br><span class="line">j: 3</span><br><span class="line">j: 4</span><br><span class="line">j: 5</span><br><span class="line">end</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dispatchqueue-4"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;concurrentQueue&quot;</span>, attributes: .concurrent)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;i: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    (<span class="number">1</span> <span class="operator">...</span> <span class="number">5</span>).forEach&#123; <span class="built_in">print</span>(<span class="string">&quot;j: &quot;</span> <span class="operator">+</span> <span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br></pre></td></tr></table></figure><p>由於執行 async 所以可以連續執行到下一個 async 和最後一個 print end，<br>並且因為是 concurrentQueue 所以 Closure1 和 Closure2 是同時進行的。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">j: 1</span><br><span class="line">i: 1</span><br><span class="line">j: 2</span><br><span class="line">i: 2</span><br><span class="line">j: 3</span><br><span class="line">i: 3</span><br><span class="line">j: 4</span><br><span class="line">i: 4</span><br><span class="line">j: 5</span><br><span class="line">i: 5</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h1 id="為什麼-async-的發動方式可以連續執行後續的程式碼呢？"><a href="#為什麼-async-的發動方式可以連續執行後續的程式碼呢？" class="headerlink" title="為什麼 async 的發動方式可以連續執行後續的程式碼呢？"></a>為什麼 async 的發動方式可以連續執行後續的程式碼呢？</h1><p>原因是因為 async 會特別建立新的 thread 來處理 async 裡的工作，<br>因此當前的執行緒可以繼續執行後續的程式碼。</p><img src="/pinkblog/2022/01/26/DispatchQueue-%E7%9A%84%E7%B0%A1%E5%96%AE%E6%87%89%E7%94%A8/5.png" class="" width="800"><hr><div class="note info flat"><p>知道上面那些組合，那他的應用情境到底是哪裡？</p></div><hr><h1 id="DispatchQueue-應用情境"><a href="#DispatchQueue-應用情境" class="headerlink" title="DispatchQueue 應用情境"></a>DispatchQueue 應用情境</h1><h2 id="情境一：處理大量資料"><a href="#情境一：處理大量資料" class="headerlink" title="情境一：處理大量資料"></a>情境一：處理大量資料</h2><p>通常不希望處理大量資料時會卡住使用者畫面，所以需要在背景執行工作。<br>可以使用 <code>DispatchQueue.global().async</code>，<br>但記得要回 main thread 才能更新畫面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleBigData</span>()</span>&#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        <span class="keyword">var</span> total <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">1000000</span>&#123;</span><br><span class="line">            total <span class="operator">+=</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Done BigData <span class="subst">\(total)</span>&quot;</span>)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Update UI on main thread.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情境二：呼叫API"><a href="#情境二：呼叫API" class="headerlink" title="情境二：呼叫API"></a>情境二：呼叫API</h2><p>最常使用的 API 三方 Alamofire 幫我們處理好了，<br>呼叫 API 前三方內部會用 async 讓畫面不會卡，<br>同時預設回應是回 main queue (也可以自行設定 queue)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleCallApi</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="type">AF</span>.request(url).response&#123;</span><br><span class="line">        response <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Done CallApi url <span class="subst">\(response)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情境三：多道API並行呼叫，全部完成時要做統一處理"><a href="#情境三：多道API並行呼叫，全部完成時要做統一處理" class="headerlink" title="情境三：多道API並行呼叫，全部完成時要做統一處理"></a>情境三：多道API並行呼叫，全部完成時要做統一處理</h2><p>多道API呼叫後的結果，可能需要最後做一個統整的處理，最後才能更新畫面。</p><p>可以利用 group(enter+leave+notify)。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleMergeApi</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url1 <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get?data=1&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url2 <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get?data=2&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">    group.enter()</span><br><span class="line">    <span class="type">AF</span>.request(url1).response&#123;</span><br><span class="line">        response <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Done MergeApi url1 <span class="subst">\(response)</span>&quot;</span>)</span><br><span class="line">        group.leave()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    group.enter()</span><br><span class="line">    <span class="type">AF</span>.request(url2).response&#123;</span><br><span class="line">        response <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Done MergeApi url2 <span class="subst">\(response)</span>&quot;</span>)</span><br><span class="line">        group.leave()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    group.notify(queue: .main) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Done MergeApi&quot;</span>)</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Merge Data or Update UI on main thread.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="情境四：一道一道呼叫API"><a href="#情境四：一道一道呼叫API" class="headerlink" title="情境四：一道一道呼叫API"></a>情境四：一道一道呼叫API</h2><p>由於 Alamofire 預設是 async 並行發送，<br>要做一點處理才能一道API完成後，再呼叫下一道API。</p><p>可以利用 group(enter+leave+wait)，但切記 wait 不可以在 main thread 上執行不然會卡死，<br>所以下面範例才使用 <code>DispatchQueue.global().async</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlePipeApi</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url1 <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get?data=1&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url2 <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get?data=2&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        group.enter()</span><br><span class="line">        <span class="type">AF</span>.request(url1).response&#123;</span><br><span class="line">            response <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Done PipeApi url1 <span class="subst">\(response)</span>&quot;</span>)</span><br><span class="line">            group.leave()</span><br><span class="line">        &#125;</span><br><span class="line">        group.wait()</span><br><span class="line">        </span><br><span class="line">        group.enter()</span><br><span class="line">        <span class="type">AF</span>.request(url2).response&#123;</span><br><span class="line">            response <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Done PipeApi url2 <span class="subst">\(response)</span>&quot;</span>)</span><br><span class="line">            group.leave()</span><br><span class="line">        &#125;</span><br><span class="line">        group.wait()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Done PipeApi&quot;</span>)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async&#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Update UI on main thread.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DispatchQueue-應用情境-Demo"><a href="#DispatchQueue-應用情境-Demo" class="headerlink" title="DispatchQueue 應用情境 Demo"></a>DispatchQueue 應用情境 Demo</h1><p><a href="https://github.com/pinkpika/DispatchQueueCase">Demo - DispatchQueueCase</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇內容以非常初階的方式介紹 DispatchQueue，&lt;br&gt;同時會說明 iOS 體系裡最流行的多緒處理的技術 GCD 和一些應用情境和範例，&lt;br&gt;後來也有用在公司培訓初次接觸 iOS 工程師的一段課程裡。&lt;/p&gt;
&lt;div class=&quot;note warning f</summary>
      
    
    
    
    <category term="iOS Development" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/"/>
    
    <category term="Multithreading" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/Multithreading/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo-RSS+Sitemap設定</title>
    <link href="http://pinkpika.github.io/pinkblog/2022/01/23/Hexo-RSS-Sitemap%E8%A8%AD%E5%AE%9A/"/>
    <id>http://pinkpika.github.io/pinkblog/2022/01/23/Hexo-RSS-Sitemap%E8%A8%AD%E5%AE%9A/</id>
    <published>2022-01-23T05:33:15.000Z</published>
    <updated>2022-01-23T18:57:03.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h1><h2 id="RSS-簡介"><a href="#RSS-簡介" class="headerlink" title="RSS 簡介"></a>RSS 簡介</h2><p>RSS 全名叫做 RDF Site Summary 或是 Really Simple Syndication，用於訂閱網站訊息的一種方式，<br>網站產生 RSS 檔案後，其他人可以利用訂閱該 RSS 的方式來觀察是否有更新內容，無需再連結或開啟網站，<br>而後也衍生出很多 RSS 閱讀器，可以在上面訂閱你關注的網站，快速閱讀多個網站內容，<br>所以為你的 Blog 製作 RSS 也是讓你的網站更容易被別人追蹤。</p><h2 id="RSS-設定方式"><a href="#RSS-設定方式" class="headerlink" title="RSS 設定方式"></a>RSS 設定方式</h2><ol><li><p>先在終端機輸入下面指令，安裝 feed 生產器</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure></li><li><p>編輯根目錄的 <code>_config.yml</code>，設定的相關參數請參考官網 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">7</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>重新產生檔案，就可以在 public 資料夾裡看到 <code>atom.xml</code> 檔案</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ol><img src="/pinkblog/2022/01/23/Hexo-RSS-Sitemap%E8%A8%AD%E5%AE%9A/1.png" class="" width="300"><hr><h1 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h1><h2 id="Sitemap-簡介"><a href="#Sitemap-簡介" class="headerlink" title="Sitemap 簡介"></a>Sitemap 簡介</h2><p>通常網站建立完成，經過時間和在 Google 搜尋的訓練下，會自動收錄網站地圖，<br>但是另一種方式就是主動提供 Sitemap，可以在網站建立後，可以提供 Sitemap 可以列出網頁清單，加速收錄網站的速度。</p><h2 id="Sitemap-設定方式"><a href="#Sitemap-設定方式" class="headerlink" title="Sitemap 設定方式"></a>Sitemap 設定方式</h2><ol><li><p>先在終端機輸入下面指令，安裝 feed 生產器</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure></li><li><p>編輯根目錄的 <code>_config.yml</code>，設定的相關參數請參考官網 <a href="https://github.com/hexojs/hexo-generator-sitemap">hexo-generator-sitemap</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">  <span class="attr">template:</span> </span><br><span class="line">  <span class="attr">rel:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>重新產生檔案，就可以在 public 資料夾裡看到 <code>sitemap.xml</code> 檔案</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></li></ol><img src="/pinkblog/2022/01/23/Hexo-RSS-Sitemap%E8%A8%AD%E5%AE%9A/2.png" class="" width="300"><ol start="4"><li>可以去 Google Search 加入網站後，並且加上 sitemap 網址</li></ol><img src="/pinkblog/2022/01/23/Hexo-RSS-Sitemap%E8%A8%AD%E5%AE%9A/3.png" class="" width="800">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RSS&quot;&gt;&lt;a href=&quot;#RSS&quot; class=&quot;headerlink&quot; title=&quot;RSS&quot;&gt;&lt;/a&gt;RSS&lt;/h1&gt;&lt;h2 id=&quot;RSS-簡介&quot;&gt;&lt;a href=&quot;#RSS-簡介&quot; class=&quot;headerlink&quot; title=&quot;RSS 簡介&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Web Development" scheme="http://pinkpika.github.io/pinkblog/categories/Web-Development/"/>
    
    <category term="Hexo" scheme="http://pinkpika.github.io/pinkblog/categories/Web-Development/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Podspec 內使用三方、Asset、Storyboard、Xib</title>
    <link href="http://pinkpika.github.io/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/"/>
    <id>http://pinkpika.github.io/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/</id>
    <published>2022-01-16T02:39:14.000Z</published>
    <updated>2022-01-30T09:34:49.909Z</updated>
    
    <content type="html"><![CDATA[<p>模組跟專案程式碼沒有什麼差別，一樣會需要依賴某個三方、使用某個三方，<br>也可能需要使用到一些 Asset 資源圖片等等和 Storyboard、Xib，理論上都是可以做得到的。</p><p>針對原本 Podspec 的資料夾結構，有進行調整，所以可以先看 <a href="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/" title="Podspec 調整資料夾結構">Podspec 調整資料夾結構</a><br>如果不調整也是沒問題，只要小心 podspec 內定義的路徑。</p><h1 id="Podspec-內使用三方"><a href="#Podspec-內使用三方" class="headerlink" title="Podspec 內使用三方"></a>Podspec 內使用三方</h1><ol><li>編輯 TestPodFramework.podspec，新增依賴三方，例如 Alamofire</li></ol><ul><li>盡量固定版號或是使用 ~&gt;，讓依賴的三方可以在固定版號之上，減少使用到錯誤版號的問題</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.dependency <span class="string">&#x27;Alamofire&#x27;</span>, <span class="string">&#x27;~&gt; 5.4.4&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>編輯 podfile，與第一步使用相同版號，重新 pod install</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">&#x27;DemoTestPodFramework&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  use_frameworks!</span><br><span class="line">  pod <span class="string">&#x27;TestPodFramework&#x27;</span>, <span class="symbol">:path</span> =&gt; <span class="string">&#x27;../&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;TestPodFramework&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  use_frameworks!</span><br><span class="line">  pod <span class="string">&#x27;Alamofire&#x27;</span>, <span class="string">&#x27;~&gt; 5.4.4&#x27;</span></span><br><span class="line">  </span><br><span class="line">  target <span class="string">&#x27;TestPodFrameworkTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="3"><li>這樣就可以在模組內使用任意三方啦！</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/1.jpg" class="" width="700"><hr><h1 id="Podspec-內使用-Asset-或是給外部使用"><a href="#Podspec-內使用-Asset-或是給外部使用" class="headerlink" title="Podspec 內使用 Asset 或是給外部使用"></a>Podspec 內使用 Asset 或是給外部使用</h1><ol><li>編輯 TestPodFramework.podspec，新增 s.resource_bundles</li></ol><ul><li>前面是指此 resource_bundle 的名稱，例如叫做 TestPodFramework</li><li>後面是指此 resource_bundle 所打包資源的位置</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.resource_bundles = &#123;</span><br><span class="line">    <span class="string">&#x27;TestPodFramework&#x27;</span> =&gt; [<span class="string">&#x27;TestPodFramework/Assets/*.*&#x27;</span>,</span><br><span class="line">                           <span class="string">&#x27;TestPodFramework/Classes/**/*.&#123;xib,storyboard&#125;&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡提醒一下，一般還有使用 s.resource、s.resources，但非常不建議這樣做，<br>因為這那種做法打包出來的 bundle 會跟專案的 main bundle 混在一起，<br>如果專案本身有相同名稱的圖片或是 storyboard，會優先使用專案的，會造成模組內的資源全失效ＱＱ</p><ol start="2"><li>打開 TestPodFramework.xcworkspace，對 Assets 新增 Assets Catalog</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/2.jpg" class="" width="800"><ol start="3"><li>模組內在 Assets Catalog 內直接加入一張圖</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/3.jpg" class="" width="400"><ol start="4"><li>模組內新增 Bundle 的 extension，讓此模組的 Bundle 在模組內或模組外都更容易找到</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bundle</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// TestPodFramework 的 Bundle 資源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> testPodFramework: <span class="type">Bundle</span>?&#123;</span><br><span class="line">        <span class="keyword">let</span> kBundle <span class="operator">=</span> <span class="string">&quot;bundle&quot;</span></span><br><span class="line">        <span class="keyword">let</span> kFramework <span class="operator">=</span> <span class="string">&quot;TestPodFramework&quot;</span></span><br><span class="line">        <span class="keyword">let</span> bundleURL <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: kFramework, withExtension: kBundle)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> bundleURL <span class="operator">=</span> bundleURL <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>(url: bundleURL)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>專案或模組只要載入圖片時指定 Bundle 即可</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageView.image <span class="operator">=</span> <span class="type">UIImage</span>(named: <span class="string">&quot;refresh&quot;</span>, in: <span class="type">Bundle</span>.testPodFramework, compatibleWith: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="Podspec-內使用-Storyboard-給外部使用"><a href="#Podspec-內使用-Storyboard-給外部使用" class="headerlink" title="Podspec 內使用 Storyboard 給外部使用"></a>Podspec 內使用 Storyboard 給外部使用</h1><ol><li>請先做上面提到的 Podspec 內使用 Asset 的”第一步”</li></ol><p>這裡會先遇到一個難處<br>要會將 ViewController 和 Storyboard 的進行連接<br>這樣初始化 VC 才會帶有完整的 Storyboard。</p><ol start="2"><li>模組內新增 protocol，來處理 ViewController 和 Storyboard</li></ol><p>有下面三個屬性來處理，都有預設的處理方式，如果有需要自行實作也可</p><ul><li>storyboardName</li><li>storyboardBundle</li><li>storyboardIdentifier</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 紀錄Storyboard的資訊</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">StoryboardInstantiable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Storyboard的名稱</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storyboardName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Storyboard的Bundle</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storyboardBundle: <span class="type">Bundle</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Storyboard的Identifier(唯一辨識名稱)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storyboardIdentifier: <span class="type">String</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 可直接產生Storyboard bind Class之後的結果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">StoryboardInstantiable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Storyboard的名稱</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storyboardName: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Storyboard的Bundle</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storyboardBundle: <span class="type">Bundle</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> selfClass <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">as?</span> <span class="type">AnyClass</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> bundle <span class="operator">=</span> <span class="type">Bundle</span>(for: selfClass)</span><br><span class="line">            <span class="keyword">return</span> bundle</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/// Storyboard的Identifier(唯一辨識名稱)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storyboardIdentifier: <span class="type">String</span>? &#123; <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 實體化(將ViewController和Storyboard綁在一起)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">instantiate</span>()</span> -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> storyboard <span class="operator">=</span> <span class="type">UIStoryboard</span>(name: storyboardName, bundle: storyboardBundle)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> storyboardIdentifier <span class="operator">=</span> storyboardIdentifier &#123;</span><br><span class="line">            <span class="keyword">return</span> storyboard.instantiateViewController(withIdentifier: storyboardIdentifier) <span class="keyword">as!</span> <span class="keyword">Self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storyboard.instantiateInitialViewController() <span class="keyword">as!</span> <span class="keyword">Self</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>CakeViewController 需要 confirm StoryboardInstantiable</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/4.jpg" class="" width="800"><ol start="4"><li>Storyboard 設定 class 和 StoryboardID</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/5.jpg" class="" width="800"><ol start="5"><li>專案或模組只要使用 instantiate 方法就可以正常載入 Storyboard!</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/6.jpg" class="" width="800"><hr><h1 id="Podspec-內使用-Nib-給外部使用-與-Storyboard-方式類似"><a href="#Podspec-內使用-Nib-給外部使用-與-Storyboard-方式類似" class="headerlink" title="Podspec 內使用 Nib 給外部使用 ( 與 Storyboard 方式類似 )"></a>Podspec 內使用 Nib 給外部使用 ( 與 Storyboard 方式類似 )</h1><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/7.jpg" class="" width="300"><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/8.jpg" class="" width="800"><img src="/pinkblog/2022/01/16/Podspec-%E5%85%A7%E4%BD%BF%E7%94%A8%E4%B8%89%E6%96%B9%E3%80%81Asset%E3%80%81Storyboard%E3%80%81Xib/9.jpg" class="" width="800"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 紀錄Nib的資訊</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">NibInstantiable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// nib的名稱</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// nib的Bundle</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibBundle: <span class="type">Bundle</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 可直接產生Nib bind Class之後的結果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">NibInstantiable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// nib的名稱</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="type">String</span>(describing: <span class="keyword">self</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// nib的Bundle</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibBundle: <span class="type">Bundle</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> selfClass <span class="operator">=</span> <span class="keyword">self</span> <span class="keyword">as?</span> <span class="type">AnyClass</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> bundle <span class="operator">=</span> <span class="type">Bundle</span>(for: selfClass)</span><br><span class="line">            <span class="keyword">return</span> bundle</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 實體化(將View和Nib綁在一起)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">instantiateFirstView</span>(<span class="params">owner</span>: <span class="keyword">Any</span><span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>)</span> -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> nib <span class="operator">=</span> <span class="type">UINib</span>(nibName: nibName, bundle: nibBundle)</span><br><span class="line">        <span class="keyword">return</span> nib.instantiate(withOwner: owner).first <span class="keyword">as!</span> <span class="keyword">Self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><div class="note info flat"><p>上面紀錄之前研究的結果，但模組的 UI 較建議還是使用”純程式碼”的方式撰寫，減少連結、打包或轉移的問題。</p></div><hr><h1 id="Demo-連結"><a href="#Demo-連結" class="headerlink" title="Demo 連結"></a>Demo 連結</h1><p><a href="https://github.com/pinkpika/TestPodFramework">TestPodFramework</a><br><a href="https://github.com/pinkpika/TestPodFramework/blob/main/TestPodFramework.podspec">TestPodFramework - podspec</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;模組跟專案程式碼沒有什麼差別，一樣會需要依賴某個三方、使用某個三方，&lt;br&gt;也可能需要使用到一些 Asset 資源圖片等等和 Storyboard、Xib，理論上都是可以做得到的。&lt;/p&gt;
&lt;p&gt;針對原本 Podspec 的資料夾結構，有進行調整，所以可以先看 &lt;a hre</summary>
      
    
    
    
    <category term="iOS Development" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/"/>
    
    <category term="Modular 模組化" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/Modular-%E6%A8%A1%E7%B5%84%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Podspec 調整資料夾結構</title>
    <link href="http://pinkpika.github.io/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/"/>
    <id>http://pinkpika.github.io/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/</id>
    <published>2022-01-16T02:38:53.000Z</published>
    <updated>2022-01-30T04:30:18.377Z</updated>
    
    <content type="html"><![CDATA[<p>由於官方的 pod lib create 產生的專案結構，模組的編譯會依賴於某個 Demo，<br>不適合單獨編譯 Framework 和做單元測試，匯入程式碼和圖片資源也要特別小心路徑，<br>也不便於建立多層子模組 Submodule 和進行管理，<br>所以我們來試著改造看看吧！</p><ul><li>原本的資料夾結構</li></ul><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/1.jpg" class="" width="400"><ul><li>最後調整後的資料夾結構</li></ul><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/9.jpg" class="" width="600"><h1 id="修改完的好處"><a href="#修改完的好處" class="headerlink" title="修改完的好處"></a>修改完的好處</h1><ul><li>可以單獨的 Scheme 可以單獨編譯 Framework，適合來跑 CICD</li><li>可以有預設的 DocC 來自動產生 Framework 文件</li><li>可以單獨跑 Framework UnitTest</li><li>可以方便管理多層子模組 Submodule</li></ul><hr><h1 id="調整資料夾步驟"><a href="#調整資料夾步驟" class="headerlink" title="調整資料夾步驟"></a>調整資料夾步驟</h1><ol><li>先將原本的 Podspec 模組資料夾換個名字，例如 TestPodFramework =&gt; TestPodFrameworkOrigin，避免等等衝突名稱</li><li>使用 Xcode 建立新的 Framework Project，命名跟原本的 Podspec 一樣就好，並且將它放在同名的資料夾裡</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/2.jpg" class="" width="600"><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/3.jpg" class="" width="600"><ol start="3"><li>將跟程式碼沒關係的部分 (LICENSE、README.md、TestPodFramework.podspec) 複製到新的 “TestPodFramework 根目錄”</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/4.jpg" class="" width="600"><ol start="4"><li>將跟程式碼和資源檔的部分 (Classes、Assets) 複製到新的 “TestPodFramework 專案裡”</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/5.jpg" class="" width="600"><ol start="5"><li>打開 TestPodFramework.xcodeproj，使用 add file 的方式把 Classes 和 Assets，確認一下可否編譯</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/6.jpg" class="" width="300"><ol start="6"><li>最後一步，因為 source_files 路徑改變，請打開 TestPodFramework.podspec，修改 s.source_files<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.source_files = <span class="string">&#x27;TestPodFramework/TestPodFramework/Classes/**/*&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="新增Demo"><a href="#新增Demo" class="headerlink" title="新增Demo"></a>新增Demo</h1><ol><li>打開 TestPodFramework.xcodeproj，按下下方，新增一個 App</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/7.jpg" class="" width="300"><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/8.jpg" class="" width="600"><ol start="2"><li>如果要將此 Demo import TestPodFramework，請先使用 pod init，新增一個 podfile</li><li>修改 podfile，最後重新 pod install</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">&#x27;DemoTestPodFramework&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pods for DemoTestPodFramework</span></span><br><span class="line">  pod <span class="string">&#x27;TestPodFramework&#x27;</span>, <span class="symbol">:path</span> =&gt; <span class="string">&#x27;../&#x27;</span> <span class="comment"># &lt;---- 請新增這行</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">target <span class="string">&#x27;TestPodFramework&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Comment the next line if you don&#x27;t want to use dynamic frameworks</span></span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pods for TestPodFramework</span></span><br><span class="line"></span><br><span class="line">  target <span class="string">&#x27;TestPodFrameworkTests&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># Pods for testing</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="4"><li>打開 TestPodFramework.xcworkspace，恭喜大功告成了</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/9.jpg" class="" width="600"><h1 id="Demo-連結"><a href="#Demo-連結" class="headerlink" title="Demo 連結"></a>Demo 連結</h1><p><a href="https://github.com/pinkpika/TestPodFramework">TestPodFramework</a><br><a href="https://github.com/pinkpika/TestPodFramework/blob/main/TestPodFramework.podspec">TestPodFramework - podspec</a></p><hr><h1 id="新增-DocC-選用"><a href="#新增-DocC-選用" class="headerlink" title="新增 DocC (選用)"></a>新增 DocC (選用)</h1><ol><li>調整 TestPodFramework.docc 裡的 TestPodFramework.md</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/10.jpg" class="" width="600"><ol start="2"><li>點擊 Product &gt; Build Documentation，即可完成！</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/11.jpg" class="" width="600"><hr><h1 id="新增-UnitTest-選用"><a href="#新增-UnitTest-選用" class="headerlink" title="新增 UnitTest (選用)"></a>新增 UnitTest (選用)</h1><ol><li>新增 UnitTest 的 Scheme，TestPodFrameworkTests</li><li>編輯 TestPodFrameworkTests，執行測試即可完成！</li></ol><img src="/pinkblog/2022/01/16/Podspec-%E8%AA%BF%E6%95%B4%E8%B3%87%E6%96%99%E5%A4%BE%E7%B5%90%E6%A7%8B/12.jpg" class="" width="600">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由於官方的 pod lib create 產生的專案結構，模組的編譯會依賴於某個 Demo，&lt;br&gt;不適合單獨編譯 Framework 和做單元測試，匯入程式碼和圖片資源也要特別小心路徑，&lt;br&gt;也不便於建立多層子模組 Submodule 和進行管理，&lt;br&gt;所以我們來試著</summary>
      
    
    
    
    <category term="iOS Development" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/"/>
    
    <category term="Modular 模組化" scheme="http://pinkpika.github.io/pinkblog/categories/iOS-Development/Modular-%E6%A8%A1%E7%B5%84%E5%8C%96/"/>
    
    
  </entry>
  
</feed>
